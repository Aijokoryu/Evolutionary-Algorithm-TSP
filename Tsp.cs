using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;

namespace Evolutionary_Algorithm_TSP {
    /// <summary>
    /// Class <c>Tsp</c> Creates a Population which represents a good (not perfect) Path, for a given TSP Problem with evolutionary and generative algorithms.
    /// </summary>
    internal class Tsp {
        /// <value>Field <c>allPaths</c> Represents a adjacency matrix which.paths[x][y] and as a result you get the cost from destination x to y </value>
        private Dictionary<int, Dictionary<int,float>> paths;

        /// <value>Field <c>firstBestPopulation</c> Best population, also used for generation new poulations</value>
        private Population firstBestPopulation;
        /// <value>Field <c>secondBestPopulation</c> Second best population, also used for generation new poulations</value>
        private Population secondBestPopulation;

        /// <value>Field <c>randomStartPopulationsAmount</c> Amount of populations that will be randomly generated by start</value>
        private int randomStartPopulationsAmount;
        /// <value>Field <c>mutationProbability</c> A value that defines how rarely a random city will be flipped with another one in the current population</value>
        private double mutationProbability;
        /// <value>Field <c>crossoverAmount</c> The amount that defines, how much a population will be split into.</value>
        private int crossoverAmount;
        /// <value>Field <c>generations</c> The amount of generations, how long the programm is trying to create a new better population.</value>
        private int generations;
        /// <value>Field <c>xmlData</c> The xml data that contains all cities and costs.</value>
        private string xmlData;

        public Tsp(string xmlData, int generations, double mutationProbability , int randomStartPopulationsAmount, int crossoverAmount) {
            paths = new Dictionary<int, Dictionary<int, float>>();
            firstBestPopulation = new Population();
            secondBestPopulation = new Population();
            this.generations = generations;
            this.xmlData = xmlData;
            LoadXMLData(xmlData);
            this.mutationProbability = mutationProbability;
            this.randomStartPopulationsAmount = randomStartPopulationsAmount;
            this.crossoverAmount = crossoverAmount;
        }
        /// <summary>
        /// Methode "LoadXMLData" Loads the xml that got passed from the XMLData folder.
        /// (<paramref name="xmlData"/>).
        /// </summary>
        /// <param name="xmlData">The Xml name that you want to open from the XMLData folder</param>
        private void LoadXMLData(string xmlData) {
            string workingDirectory = Environment.CurrentDirectory;
            string projektPath = Directory.GetParent(workingDirectory).Parent.Parent.FullName;
            string xmlPath= projektPath+"\\XMLData\\"+ xmlData;

            //load xml data
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.Load(xmlPath);
            XmlNodeList xmlNodeList = xmlDoc.GetElementsByTagName("vertex");

            //fill Dictionary as adjacency matrix
            int i = 0; //current vertex
            int modifier = 0;
            foreach (XmlElement vertex in xmlNodeList) { //vertexe
                Dictionary<int, float> vertexDict = new Dictionary<int, float>();
                for (int j =0; j< xmlNodeList.Count; j++ ) { //edges
                    
                    //each node doesnt have a distance to itsself therefore we fill it with 0, however be aware that its 0!
                    if (i == j) {
                        vertexDict.Add(j, 0);
                        modifier = 1;
                    } else {
                        XmlNode edge = vertex.ChildNodes[j-modifier];
                        vertexDict.Add(int.Parse(edge.InnerText), float.Parse(edge.Attributes["cost"].Value));
                    }
                    //Console.WriteLine("Edge:" + j+ " Value:" + vertexDict[j]);
                }
                paths.Add(i, vertexDict);
                modifier = 0;
                i++;
            }
        }
        /// <summary>
        /// Methode "GenerateSolution" Is the external starting point of the Programm. 
        /// It starts the hole process of creating a Solution for the given TSP problem file and prints out the result.
        /// </summary>
        public void GenerateSolution() {

            Timer timer = new Timer();
            do {
                Console.Clear();
                timer.StartTimer();
                firstBestPopulation = new Population();
                secondBestPopulation = new Population();
                int improvement = 0;
                int lastImprovement = 0;

                InitialPopulation();
                for (int i = 0; i < generations; i++) {
                    //parent selection, however since we always have only 2 parents, we dont need to look select new parents
                    Population newPopulation = Variation();
                    Evaluation(newPopulation, ref improvement);
                }
                Console.WriteLine("Your settings:\nXMLData" + xmlData + "\nGenerations:" + generations + "\nMutationprobability:" + mutationProbability
                 + "\nStart Populations (without the 2 default):" + randomStartPopulationsAmount + "\nCrossovers:" + crossoverAmount+"\n");

                Console.WriteLine(firstBestPopulation);
                timer.StopTimer();
                timer.CalculateDifference();
                Console.WriteLine("Want to retry? Press Y|y\n");
            } while (Console.ReadLine().ToLower() == "y");
        }
        /// <summary>
        /// Methode "InitialPopulation" Creates a minimum of two populations and if the class variable "randomStartPopulationsAmount" 
        /// is greater than 0 than you create that amount of new random generated populations and evaluate those and use the best of 
        /// two them.
        /// </summary>
        private void InitialPopulation() {
            //initialise minimum of 2 Populations
            Population firstPopulation = GenerateFirstRandomPath();
            Population secondPopulation = GenerateFirstRandomPath();
            if (firstPopulation.fitnessValue < secondPopulation.fitnessValue) {
                firstBestPopulation= firstPopulation;
                secondBestPopulation=secondPopulation;
            } else {
                secondBestPopulation = firstPopulation;
                firstBestPopulation = secondPopulation;
            }
            Console.WriteLine("First Population:\n" + firstBestPopulation + "\n" + "Second population:\n" + secondBestPopulation+"\n\n");


            int improvement =0; 
            //generate random populations if you'd like, can help, but can also be a timewaste xd
            for (int i = 0; i < randomStartPopulationsAmount; i++) {
                Population tempPopulation = GenerateFirstRandomPath();
                Evaluation(tempPopulation, ref improvement);
            }
            Console.WriteLine("The start generations generated " + improvement + " improvements\n");
        }
        /// <summary>
        /// Methode "Evaluation" Evaluates if the given population might be better than the current best populations.
        /// (<paramref name="population"/>).
        /// </summary>
        /// <param name="population">The Population which gets compared to the best populations</param>
        private void Evaluation(Population population, ref int improvement) {
            if (population.fitnessValue < firstBestPopulation.fitnessValue) {
                improvement = improvement + 1;
                secondBestPopulation = firstBestPopulation;
                firstBestPopulation = population;
                Console.WriteLine("1 got updated to:" + firstBestPopulation.fitnessValue);
                Console.WriteLine("2 got updated to:" + secondBestPopulation.fitnessValue + "\n");
            } else if (population.fitnessValue < secondBestPopulation.fitnessValue) {
                improvement = improvement + 1;
                secondBestPopulation = population;
                Console.WriteLine("2 got updated to:" + secondBestPopulation.fitnessValue + "\n");
            }
        }
        /// <summary>
        /// Methode "Variation" makes a crossover and mutation.
        /// </summary>
        private Population Variation() {
            //Crossover + Mutation
            Population newPopulation = Crossover();
            newPopulation = Mutation(newPopulation);
            newPopulation.RecalculateFitnessValue(paths);
            return newPopulation;
        }

        /// <summary>
        /// Methode "Crossover" Rearrangement of genetic material from multiple (two) parents.
        /// </summary>
        private Population Crossover() {
            Decimal amountOfCititesPerIteration = Math.Ceiling((Decimal)firstBestPopulation.individuals.Count / (crossoverAmount));
            
            int startIndex= 0;
            List<Tuple<int,int>> crossoverSectors = new List<Tuple<int,int>>();

            for (int crossoverIteration = 0; crossoverIteration < crossoverAmount; crossoverIteration++)
            {
                //set end indexes for each section
                int endIndex = (int)(startIndex + amountOfCititesPerIteration - 1);
                if (endIndex > firstBestPopulation.individuals.Count) endIndex = firstBestPopulation.individuals.Count-1;

                //insert the section ranges to the list
                crossoverSectors.Add(new Tuple<int, int>(startIndex, endIndex));

                //set new start value
                startIndex = endIndex + 1;

            }

            //now we know how long each section should be
            //create new Population
            Population newPopulation= new Population();

            foreach (Tuple<int, int> tuple in crossoverSectors) {
                Population firstOriginalPopulation = new Population();
                Population secondOriginalPopulation = new Population();
                //for each section range, get the best Individuals from the best Populations, and add those to the temporary Populations
                for (int index = tuple.Item1;  index < tuple.Item2+1 ; index++)
                {
                    firstOriginalPopulation.AddIndividual(firstBestPopulation.individuals[index].vertex);
                    secondOriginalPopulation.AddIndividual(secondBestPopulation.individuals[index].vertex);
                }

                //recalculate the cost of each section
                firstOriginalPopulation.RecalculateFitnessValue(paths);
                secondOriginalPopulation.RecalculateFitnessValue(paths);


                //now check if the given Individuals from one section are in the other one
                //we do this because, we want to ensure that we dont have duplicates, and
                //dont want to create something like [ from city:1, to city:1]
                //therefore we can only add parts, where it matches => and we already have the value

                //also helps a lot for improving if you think about it
                bool match = true;
                foreach (Individual individual in firstOriginalPopulation.individuals) {
                    if (secondOriginalPopulation.individuals.Contains(individual)) {
                        match = false;
                        break;
                    }
                }
                
                //if we have a match we take the the individual which is in the path that is better (smaller cost)
                //else just add from the first, since the first is also the bestPopulation and its more likely that this results in better values
                for (int index = tuple.Item1; index < tuple.Item2+1; index++)
                {
                    if (match && firstOriginalPopulation.fitnessValue > secondOriginalPopulation.fitnessValue) {
                        newPopulation.AddIndividual(secondBestPopulation.individuals[index].vertex);
                    } else {
                        newPopulation.AddIndividual(firstBestPopulation.individuals[index].vertex);
                    }
                }
            }
            newPopulation.RecalculateFitnessValue(paths);
            return newPopulation;
        }
        /// <summary>
        /// Methode "Mutation" swaps two Individual points in the population when a random value is in your Mutation probability.
        /// Returns the passed Population. If things got swapped then it returns the changed population
        /// (<paramref name="population"/>).
        /// </summary>
        /// <param name="population">The Population where points get swapped</param>
        private Population Mutation(Population population) {
            Random random = new Random();
            if (random.Next(1, 101) > mutationProbability) return population;

            
            int randomIndexFirst = random.Next(0, population.individuals.Count); 
            int randomIndexSecond = random.Next(0, population.individuals.Count);
            while (randomIndexFirst == randomIndexSecond) {
                randomIndexSecond = random.Next(0, population.individuals.Count);
            }
            Individual individual = population.individuals[randomIndexFirst];
            population.individuals[randomIndexFirst] = population.individuals[randomIndexSecond];
            population.individuals[randomIndexSecond] = individual;
            population.RecalculateFitnessValue(paths);
            return population;

        }

        /// <summary>
        /// Methode "GenerateFirstRandomPath" Creates a random path and returns it.
        /// </summary>
        public Population GenerateFirstRandomPath() {
            //fill list with vertex numbers
            int individualAmountLeft = paths.Count;
            int[] possibleIndividuals = new int[paths.Count];
            for (int i = 0; i < paths.Count; i++) possibleIndividuals[i] =i;
            Random.Shared.Shuffle(possibleIndividuals);
            Population population = new Population();

            while (individualAmountLeft != 0) {
                population.AddIndividual(possibleIndividuals[individualAmountLeft - 1]);
                individualAmountLeft--;
            }
            population.RecalculateFitnessValue(paths);
            return population;
        }
       
    }
}
